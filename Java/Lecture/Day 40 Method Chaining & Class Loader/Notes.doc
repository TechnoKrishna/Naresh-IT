------------------------------------------------------------

‚≠ê PART‚Äì1: Method Chaining in Java

Method Chaining means calling multiple methods one after another in a single line, where the next method always depends on the return value of the previous method.

Imagine you go to a shop and say in one sentence:

"Give me a burger ‚Üí add cheese ‚Üí pack it ‚Üí bill it."

You didn‚Äôt stop after each step.
You gave a CHAIN of commands in one sentence.

This is exactly what happens in method chaining:

str.concat(" is great").toLowerCase().charAt(1);

concat() returns a String
On that String we call toLowerCase() which again returns a String
On that returned String we call charAt(1) which returns a char
So each method returns a value that allows the next method to be called.

‚≠ê Example:

String str = "INDIA";
char ch = str.concat(" is great ").toLowerCase().charAt(1);
System.out.println(ch);

‚úî str.concat() ‚Üí gives "INDIA is great"
‚úî .toLowerCase() ‚Üí "india is great"
‚úî .charAt(1) ‚Üí 'n'

------------------------------------------------------------

‚≠ê PART‚Äì2: Why Method Chaining Works?

Because return type of current method becomes the caller for the next method.

Example:

| Method        | Return Type |
| ------------- | ----------- |
| concat()      | String      |
| toLowerCase() | String      |
| charAt()      | char        |

Since the last return type is char, the final variable must be char.

------------------------------------------------------------

‚≠ê Real-Life Example for Method Chaining

üìû Mobile Example
You pick up your phone and do:

Open WhatsApp
Open a chat
Type message
Send message

If you automate it:

openWhatsapp().openChat().typeMessage().send();

This represents method chaining.

------------------------------------------------------------

‚≠ê PART‚Äì3: What is Class Loading in Java?

When a .class file (compiled Java file) is needed, JVM must bring it into memory.
This job is done by Class Loaders.

When any class gets loaded into JVM:

‚úî It is stored inside a special memory area ‚Üí Method Area
‚úî JVM automatically creates an object of java.lang.Class

Example : Class cls = Employee.class;

Here, Employee.class loads the class into JVM ‚Üí returns a Class object.

------------------------------------------------------------

‚≠ê PART‚Äì4: java.lang.Class Object

‚úî Important Points:

Every time a class is loaded, JVM creates one Class object.
This object represents the metadata of the class.
It is stored in Method Area.
Using this Class object, we can:
    get the class name
    find its class loader
    know fields / methods / constructors (Reflection)

------------------------------------------------------------

‚≠ê getName()

Returns fully qualified class name:
packageName.className

Example : System.out.println(cls.getName());

If Employee is in package com.ravi, output : com.ravi.Employee

------------------------------------------------------------

‚≠ê PART‚Äì5: Types of Class Loaders in Java

Java defines 3 class loaders:

| Class Loader             | Loads                        |
| ------------------------ | ---------------------------- |
| Bootstrap Class Loader   | Core Java classes (`java.*`) |
| Platform Class Loader    | JDK module classes           |
| Application Class Loader | User-defined classes         |

------------------------------------------------------------

‚≠ê PART‚Äì6: Application Class Loader Example

Class cls = Test.class;
System.out.println(cls.getClassLoader());

Output something like:
jdk.internal.loader.ClassLoaders$AppClassLoader@<hash>

This proves Application Class Loader loads user .class files.

------------------------------------------------------------

‚≠ê PART‚Äì7: Platform Class Loader (Parent of App Class Loader)

Foo.class.getClassLoader().getParent();

Foo.class.getClassLoader() ‚Üí Application CL
.getParent() ‚Üí Platform CL

------------------------------------------------------------

‚≠ê PART‚Äì8: Bootstrap Class Loader

Sample.class.getClassLoader().getParent().getParent();
System.out.println(String.class.getClassLoader());

Bootstrap Cls Loader returns null
because it is implemented in native code (C/C++), not in Java.

So JVM returns : null

------------------------------------------------------------

‚≠ê Easy Real-Life Example of Class Loaders

Think of a 3-level school system:

1Ô∏è‚É£ Bootstrap CL ‚Üí Principal
Loads the most important classes (rules, books)
    No one is above him (so parent = null)

2Ô∏è‚É£ Platform CL ‚Üí Teachers
Loads important JDK-level classes.

3Ô∏è‚É£ Application CL ‚Üí Students
Loads your program (.class files)

The hierarchy:

Principal (Bootstrap)
      ‚Üë
Teachers (Platform)
      ‚Üë
Students (Application)

------------------------------------------------------------

‚≠ê PART‚Äì9: Why Class Loader Hierarchy?

‚úî Security
‚úî Avoid duplicate classes
‚úî Organized loading
‚úî Faster access

Example:

If you write a class named String, JVM should not load your class instead of Java‚Äôs String class.

So Bootstrap loader loads core classes first.

------------------------------------------------------------

‚≠ê PART‚Äì10: Summary

üßµ METHOD CHAINING

Call multiple methods in one statement
Each method returns something ‚Üí next method uses it
Last method return decides final type

üìö CLASS LOADING

JVM loads classes into Method Area

For every loaded class, JVM creates a java.lang.Class object

This object contains class metadata

üî• CLASS LOADERS

Bootstrap Loader ‚Üí loads Java core classes
Platform Loader ‚Üí loads JDK modules
Application Loader ‚Üí loads your classes

üí°Key methods:

getName() ‚Üí fully qualified class name
getClassLoader() ‚Üí which loader loaded the class
getParent() ‚Üí parent class loader

------------------------------------------------------------