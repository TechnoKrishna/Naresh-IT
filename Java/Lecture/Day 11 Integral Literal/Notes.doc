    Integral Literals in Java

    An integral literal is any numeric constant without a decimal point or fraction.

    ðŸ‘‰ Example: 12, 90, 34, 78

    Java provides 4 data types to store integral literals:

    a) byte â†’ 8 bits
    b) short â†’ 16 bits
    c) int â†’ 32 bits (default type)
    d) long â†’ 64 bits

    Forms of Integral Literals

    We can represent integral literals in 4 different number systems:

    a) Decimal Literal (Base 10 â†’ digits 0â€“9)
    b) Octal Literal (Base 8 â†’ digits 0â€“7)
    c) Hexadecimal Literal (Base 16 â†’ digits 0â€“9, Aâ€“F or aâ€“f)
    d) Binary Literal (Base 2 â†’ digits 0 and 1, available from JDK 1.7)

    1. Decimal Literall :

    By default, numbers are considered decimal literals.
    Base is 10 â†’ accepts digits 0â€“9.

    Example :
    int x = 20;
    int y = 123;
    int z = 234;

    2. Octal Literal :

    If a number starts with 0, it is treated as an octal literal.
    Base is 8 â†’ accepts digits 0â€“7.

    Example :

    int a = 0777;  // Valid (octal for 511 in decimal)
    int b = 0123;  // Valid (octal for 83 in decimal)

    int c = 018; // Invalid â†’ '8' is not allowed in octal

    3. Hexadecimal Literal :

   If a number starts with 0x or 0X, it is treated as a hexadecimal literal.
   
   Base is 16 â†’ accepts digits 0â€“9 and Aâ€“F (case-insensitive).

    Example :

    int x = 0x12;    // Valid (decimal 18)
    int y = 0xAdd;   // Valid (decimal 2781)
    int z = 0xFace;  // Valid (decimal 64206)
    int a = 0xage; // Invalid â†’ 'g' is not allowed in hexadecimal


    4. Binary Literal :

    If a number starts with 0b or 0B, it is treated as a binary literal.
    Base is 2 â†’ accepts digits 0 and 1.
    Introduced in JDK 1.7.

    Example :
    int x = 0B101;  // Valid (decimal 5)
    int y = 0b111;  // Valid (decimal 7)

    int z = 0B112; // Invalid â†’ '2' is not allowed in binary

    Key Point

    Even though we can write literals in decimal, octal, hexadecimal, or binary,
    ðŸ‘‰ The JVM always converts them into decimal internally when executing the program.

    // Conversion : 

    2  1  0
    |  |  |
    5  2  3

    5 x 10^2 + 2 x 10^1 + 3 x 10^0

    public class OctalLiteral
    {
        public static void main(String[] args)
        {
            int x = 015;
            System.out.printin(x);
        }
    }

    015 -> Here 0 describes that It is an octal literal.

    (15) = (?)
        8    10


    1 x 8^1 + 5 x 8^0

    1 X 8 + 5

    8 + 5 = 13

    //Hexadecimal Example :

    public class HexadecimalDemo
    {
        public static void main(String[] args)
        {
            int x = 0Xadd
            System.out.printin(x);
        }
    }

    OXadd -> Here OX represents It is a hexadecimal number.

    2  1  0
    |  |  |
   (a  d  d) = (?)
           16     10

    A = 10
    B = 11
    C = 12
    D = 13
    E = 14
    F = 15

    a X 16^2 + d X 16^1 + d x 16^0

    10 X 256 + 13 X 16 + 13 X 1

    => 2560 + 208 + 13
    => 2781

    //Example of Binary

    public class BinaryLiteral
    {
        public static void main(String[] args)
        {
            int x = 0B101;
            System.out.printin(x);
        }
    }

    How we are representing intergal literal in memory :

    byte a = 5; -> 00000101 [8 bits representation]
    short b = 5; -> 00000000 00000101 [16 bits representation]
    int c = 5; -> 00000000 00000000 00000000 00000101 [32 bits representation]
    long d = 5; -> 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101 [64 bits representation]

    Default Type of Integral Literals in Java.
    By default, every integral literal in Java is of type int (32-bit).
    If we assign an integral literal to byte or short, the compiler automatically converts it â€” but only if the value is within the valid range:
    byte range: -128 to 127
    short range: -32768 to 32767

    1. Assigning int literals to byte and short

    When we assign an int literal to byte or short, the compiler internally performs type conversion:

    byte b = 12;    // Compiler converts int(12) â†’ byte
    short s = 1200; // Compiler converts int(1200) â†’ short

    Internally, the compiler does something like this:

    byte b = (byte) 12;
    short s = (short) 1200;

    âœ… Valid Example:

    byte b = 100;  // Within byte range (-128 to 127)
    short s = 3000; // Within short range (-32768 to 32767)

    âŒ Invalid Example (Out of Range):

    byte b = 200;   // Error: 200 is not in byte range

    2. Representing Long Literals

    To represent a long literal explicitly, we must add a suffix:
        L or l â†’ both work, but L (capital) is recommended.
        Reason: lowercase l looks like the digit 1, which is confusing.

    âœ… Example:

    long x = 123456789L; // Correct


    âŒ Wrong Example (will be treated as int, may cause error if too big):

    long x = 123456789;  // Error if number exceeds int range


    // Different Cases :

    Integral Literals â€“ Cases & Explanations

Case 1: Assigning int literal to byte

    byte b = 12; // Compiler will convert int â†’ byte

    Default type of 12 is int.

    Since 12 is within byte range (-128 to 127), compiler implicitly converts it. âœ… No error.

Case 2: Assigning int literal to short

    short s = 25; // Compiler will convert int â†’ short

    Default type of 25 is int.

    Since 25 is within short range (-32768 to 32767), compiler converts it safely. âœ… No error.

Case 3: Byte range exceeded

    byte b = 128; // Compilation error

    128 is outside byte range (-128 to 127).
    âŒ Error: possible lossy conversion from int to byte.

Case 4: Short range exceeded

    short s = 32768; // Compilation error

    32768 is outside short range (-32768 to 32767).
    âŒ Error: possible lossy conversion from int to short.

Case 5: int to int

    int x = 12; // int â†’ int (32-bit to 32-bit)

    No conversion needed.
    âœ… No error.

Case 6: int to long

    long y = 90; // int â†’ long (32-bit to 64-bit)
    90 is int by default.

    Since long can hold int values, compiler implicitly promotes it.
    âœ… No error.

Case 7: Large number without L suffix

    long mob = 9812345678; // Error
    
    By default, 9812345678 is int.
    But int max range is 2,147,483,647.
    Since 9812345678 > int range â†’ compiler error:
    âŒ integer number too large.

Case 8: Large number with L suffix

    long mob = 9812345678L; // long â†’ long

    Adding L makes it a long literal.
    Fits in long range.
    âœ… No error.

Case 9: Method parameter with byte
    public static void main(String[] args) 
    {
    accept(1);
    }

    public static void accept(byte b) 
    {
    }

    1 is an int literal by default.

    Java does implicit narrowing for method calls only if the value fits in byte range.

    Since 1 is within byte range (-128 to 127), compiler converts int â†’ byte.
    âœ… Works fine.

Case 10: int literal passed to byte parameter

    public class Test {
        public static void main(String[] args) {
            accept(10);  // Passing int literal
        }

        public static void accept(byte b) {
            System.out.println("Byte value: " + b);
        }
    }

    10 is an int literal by default.

    Since 10 is within byte range (-128 to 127) â†’ compiler allows implicit conversion.

Case 11: int literal out of byte range

    public class Test {
        public static void main(String[] args) {
            accept(200);  // Error
        

        public static void accept(byte b) {
            System.out.println("Byte value: " + b);
        }
    }

    200 is an int literal, but it is out of byte range.

    Compiler does not allow implicit conversion here.

    ðŸ‘‰ Compilation error:

    error: incompatible types: possible lossy conversion from int to byte

    Key Takeaways

    1 > Default integral literal = int.
    2 > Byte and short can take int literals only if theyâ€™re within range.
    3 > Use L suffix for long values exceeding int range.
    4 > Method calls allow int to byte/short conversion if value fits in range.