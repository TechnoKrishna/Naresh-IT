// 1. By Default Every Integral Literal is of type int only

public class Test4 {
    public static void main (String[] args) {
        byte b = 128;     // ‚ùå Error: 128 is out of byte range (-128 to 127)
        System.out.println(b);

        short s = 32768;  // ‚ùå Error: 32768 is out of short range (-32768 to 32767)
        System.out.println(s);

        short x = 1;
        byte bb = x;      // ‚ùå Error: Cannot assign short to byte without casting
        System.out.println(bb);
    }
}

üí° Explanation :

- 128 is by default an int, but it doesn‚Äôt fit into byte.
- 32768 doesn‚Äôt fit into short.
- Even if x = 1 is in range, assigning short ‚Üí byte requires explicit casting.

// 2. Widening (Smaller ‚Üí Bigger)

public class Test5 {
    public static void main (String[] args) {
        byte b = 125;
        short s = b;   // ‚úÖ Widening (byte ‚Üí short)
        System.out.println(s);

        short x = 345;
        int y = x;     // ‚úÖ Widening (short ‚Üí int)
        System.out.println(y);
    }
}

üí° Explanation:

- Widening = Automatic type conversion (safe, no data loss).
- byte ‚Üí short ‚Üí int ‚Üí long ‚Üí float ‚Üí double.

// 3. Narrowing (Bigger ‚Üí Smaller)

public class Test6 {
    public static void main(String[] args) {
        short s = 127;
        byte b = (byte) s;  // ‚úÖ Explicit narrowing
        System.out.println(b);
    }
}

üí° Explanation:

- Narrowing = Explicit cast required.
- Possible data loss if value doesn‚Äôt fit.

// 4. Explicit Casting Examples

public class Test7 {
    public static void main(String[] args) {
        byte x = (byte) 18L;   // long ‚Üí byte
        System.out.println("x value = " + x);

        long l = 29L;          // ‚úÖ valid long
        System.out.println("l value = " + l);

        int y = (int) 1L;       // long ‚Üí int (needs cast, but safe here)
        System.out.println("y value = " + y);
    }
}

Key Notes

Default integral literal = int
    Example: 100 is int by default.

Widening (small ‚Üí big) = automatic
    Example: byte ‚Üí short ‚Üí int ‚Üí long ‚Üí float ‚Üí double.

Narrowing (big ‚Üí small) = explicit cast
    Example: long ‚Üí int ‚Üí short ‚Üí byte.

Data Loss Possible in Narrowing
    Example: (byte) 200 ‚Üí -56 because it overflows byte range.

///////////////////////////////////////////////////////////////////////////////////////////////

Q ) Is Java a Pure Object-Oriented Programming Language?

üëâ Answer: No, Java is not a pure object-oriented language.

Here‚Äôs why:

1. Primitive Data Types

    Java supports 8 primitive data types which are not objects:
    - byte, short, int, long, float, double, char, boolean

    In a pure object-oriented language (like Ruby or Smalltalk), everything is an object.

    Since Java allows primitives, it breaks the "pure" object-oriented rule.

2. Objects Everywhere Else

    Apart from these 8 primitives, everything in Java is an object.
    - Example: Strings, Arrays, Classes, Interfaces, etc.

3. Wrapper Classes

    In networking and collections, Java only works with objects, not primitives.
    - To solve this, Java provides Wrapper Classes for each primitive type:

    | Primitive Type | Wrapper Class |
    | -------------- | ------------- |
    | `byte`         | `Byte`        |
    | `short`        | `Short`       |
    | `int`          | `Integer`     |
    | `long`         | `Long`        |
    | `float`        | `Float`       |
    | `double`       | `Double`      |
    | `char`         | `Character`   |
    | `boolean`      | `Boolean`     |

4. Autoboxing and Unboxing (from JDK 1.5 onwards)

- Autoboxing ‚Üí Automatic conversion of primitive ‚Üí wrapper object.

- Unboxing ‚Üí Automatic conversion of wrapper object ‚Üí primitive.

public class WrapperDemo {
    public static void main(String[] args) {
        // Autoboxing (primitive ‚Üí object)
        int a = 10;
        Integer obj = a;  // compiler converts int ‚Üí Integer

        // Unboxing (object ‚Üí primitive)
        Integer num = 20;
        int b = num;  // compiler converts Integer ‚Üí int

        System.out.println("Object: " + obj);
        System.out.println("Primitive: " + b);
    }
}

‚úÖ Final Conclusion

- Java is not a pure object-oriented programming language because of primitive data types.
- But, using Wrapper classes + Autoboxing/Unboxing, primitives can also behave like objects.

// Program to show the use of Wrapper Classes
public class Test8 {
    public static void main(String[] args) {
        // Autoboxing: int ‚Üí Integer
        Integer x = 24;
        Integer y = 24;

        // Here x and y are Integer objects, but Java does unboxing (Integer ‚Üí int) to perform addition
        Integer z = x + y; // result autoboxed back into Integer
        System.out.println("The sum is : " + z);

        // Wrapper for boolean
        Boolean b = true;
        System.out.println("Boolean value: " + b);

        // Wrapper for double
        Double d = 90.90;
        System.out.println("Double value: " + d);

        // Wrapper for char
        Character c = 'A';
        System.out.println("Character value: " + c);
    }
}

üìå Explanation

- Integer x = 24; ‚Üí Autoboxing (primitive int 24 ‚Üí Integer object).
- z = x + y;
- Behind the scenes: Unboxing (Integer ‚Üí int) ‚Üí addition performed ‚Üí Autoboxing back into Integer.

- Same applies for Boolean, Double, and Character.

Output:

    The sum is : 48
    Boolean value: true
    Double value: 90.9
    Character value: A


// Program to find out the range and size of Integral Data types

public class Test9 { 
    public static void main(String[] args) {
        System.out.println("\nByte range:");
        System.out.println(" min: " + Byte.MIN_VALUE);
        System.out.println(" max: " + Byte.MAX_VALUE);
        System.out.println(" size: " + Byte.SIZE + " bits");

        System.out.println("\nShort range:");
        System.out.println(" min: " + Short.MIN_VALUE);
        System.out.println(" max: " + Short.MAX_VALUE);
        System.out.println(" size: " + Short.SIZE + " bits");

        System.out.println("\nInteger range:");
        System.out.println(" min: " + Integer.MIN_VALUE);
        System.out.println(" max: " + Integer.MAX_VALUE);
        System.out.println(" size: " + Integer.SIZE + " bits");

        System.out.println("\nLong range:");
        System.out.println(" min: " + Long.MIN_VALUE);
        System.out.println(" max: " + Long.MAX_VALUE);
        System.out.println(" size: " + Long.SIZE + " bits");
    }
}

‚ú® Explanation

Every Wrapper class (Byte, Short, Integer, Long) contains:

    - MIN_VALUE ‚Üí Smallest value the type can hold
    - MAX_VALUE ‚Üí Largest value the type can hold
    - SIZE ‚Üí Number of bits used to store the type

For example:

    - Byte.MIN_VALUE ‚Üí -128
    - Byte.MAX_VALUE ‚Üí 127
    - Byte.SIZE ‚Üí 8 bits

// Providing _ (underscore) in integeral Literal :

- Underscore (_) in numeric literals (introduced in Java 7)
- Compile-time constant assignment (when assigning final variables)

1Ô∏è‚É£ Underscore in Numeric Literals (JDK 1.7+)

üëâ Purpose: To improve readability of large numbers.

‚úÖ Allowed:

- Between digits (e.g., 1_000_000)
- Between groups of digits (e.g., 9_876_543_210L)

‚ùå Not allowed:

- At the beginning or end of a number (_123, 123_)
- Next to decimal point (3._14, 3_.14)
- Before suffix (123_L)

public class Test10 {
    public static void main(String[] args) {
        long mobile = 98_1234_5678L; // using _ for readability
        System.out.println("Mobile Number is : " + mobile);
    }
}

üëâ Output:

- Mobile Number is : 9812345678

2Ô∏è‚É£ Final variable & byte assignment

- In Java, a final int with a constant value can be implicitly cast into a smaller type (like byte) if the value is within the range of that type.

public class Test11 {
    public static void main(String[] args) {
        final int x = 127; // final + value within byte range (-128 to 127)
        byte b = x;        // allowed at compile time
        System.out.println(b);
    }
}

üëâ Output:

- 127

But if you try:

- final int y = 200;
- byte b2 = y;   // ‚ùå Compilation Error (out of byte range)

‚úÖ Summary:

- Use _ inside numeric literals (Java 7+) for readability.
- final int can be assigned to a smaller type (like byte) if the value fits in the range.

// How to convert decimal to another number system like octal, hexadecimal and binary :

‚úÖ Explanation of Methods

1 > Integer.toHexString(int x)

- Converts decimal to Hexadecimal
- Hex digits ‚Üí 0‚Äì9 and a‚Äìf
- Example: 2781 ‚Üí ad5

2 > Integer.toOctalString(int x)

- Converts decimal to Octal
- Octal digits ‚Üí 0‚Äì7
- Example: 17 ‚Üí 21

3 > Integer.toBinaryString(int x)

- Converts decimal to Binary
- Binary digits ‚Üí 0 and 1
- Example: 7 ‚Üí 111

‚ö° Correct Program

public class Test12 {
    public static void main(String[] args) {
        int x = 2781;
        System.out.println("Decimal " + x + " in Hexadecimal: " + Integer.toHexString(x));

        int y = 17;
        System.out.println("Decimal " + y + " in Octal: " + Integer.toOctalString(y));

        int z = 7;
        System.out.println("Decimal " + z + " in Binary: " + Integer.toBinaryString(z));
    }
}

üñ•Ô∏è Output

- Decimal 2781 in Hexadecimal: ad5
- Decimal 17 in Octal: 21
- Decimal 7 in Binary: 111

‚úÖ Key Note:

- Return type of all these methods is String.
- Useful when you need to display numbers in different number systems.

‚úÖ Key Points about var in Java

1 > Introduced in Java 10

    - Used for local variable type inference.
    - The compiler decides the type at compile time, based on the value you assign.

2 > Initialization is mandatory

    - var x = 12; // compiler infers int

3 > Once inferred, type is fixed

    - var a = 12;  // int
    - a = true;   // ‚ùå error (cannot assign boolean to int)

4 > Can be used only for local variables

    - Not allowed for class fields, method parameters, or return types.

5 > Still strongly typed

    - var is not like var in JavaScript.
    - It‚Äôs just a shorthand for writing type explicitly.

‚ö° Example Program

// var keyword [Introduced from Java 10]

public class Test13 {
    public static void main(String[] args) {
        var x = 12; // x is int
        System.out.println(x);

        x = 90; // valid, still int
        System.out.println(x);

        // x = 90.89; // ‚ùå Invalid, x is int not double

        var name = "Krishna"; // name is String
        System.out.println(name);

        var pi = 3.14159; // pi is double
        System.out.println(pi);

        var flag = true; // flag is boolean
        System.out.println(flag);
    }
}

üñ•Ô∏è Output
- 12
- 90
- Krishna
- 3.14159
- true