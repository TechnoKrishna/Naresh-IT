ğŸŒŸ Polymorphism

--------------------------------------------------------------------------------------------------------

The word Polymorphism comes from:

Poly â†’ many
Morphism â†’ forms

So Polymorphism means â€œone thing behaving in many ways.â€

ğŸ§ Real-life example:

Think about you.

You = one person
But you behave differently in different situations:

As a student in class
As a friend with your best friend
As a customer in a shop
As a player on a playground

ğŸ‘‰ Same person, different behaviors â†’ Polymorphism

--------------------------------------------------------------------------------------------------------

ğŸ’» Programming connection:

Just like a human behaves differently, a method can also behave differently depending on the parameters or object calling it.

Example:

void add(int a, int b)
void add(int a, int b, int c)
void add(float a, float b)
void add(int a, float b)

All methods have the same name (add)
But each performs differently based on the parameters.

--------------------------------------------------------------------------------------------------------

â­ Types of Polymorphism

Polymorphism is divided into:

1ï¸âƒ£ Static Polymorphism (Compile-time / Early Binding)
2ï¸âƒ£ Dynamic Polymorphism (Runtime / Late Binding)

--------------------------------------------------------------------------------------------------------

ğŸ”µ 1) Static Polymorphism (Compile-time Polymorphism)

This type of polymorphism is decided during compilation by the compiler.

âœ” Why is it called compile-time?

Because the compiler already knows which method to call, based on:
Number of parameters
Type of parameters
Order of parameters

âœ” Binding at compile time

The method is linked to the call before the program actually runs â†’ this is called early binding.

âœ” Achieved using: ğŸ‘‰ Method Overloading

ğŸ” Example:

void show(int a)
void show(double a)

Here the compiler knows:

If argument is int â†’ call show(int)
If argument is double â†’ call show(double)

ğŸ§ Real-life example:

When you dial a phone number:
If you dial 100 â†’ Police
If you dial 101 â†’ Fire
If you dial 102 â†’ Ambulance

The system knows during dialing time which service to call.
ğŸ‘‰ Decision made immediately â†’ compile-time

--------------------------------------------------------------------------------------------------------

ğŸ”´ 2) Dynamic Polymorphism (Runtime Polymorphism)

In this type, the decision is made at runtime (while the program is running).

âœ” Why runtime?

Because JVM decides which method to call based on the object type, not the reference type.

âœ” Binding at runtime

Method is linked to the object while running the program â†’ late binding

âœ” Achieved using: ğŸ‘‰ Method Overriding

ğŸ” Example:

class A { void display(){} }
class B extends A { void display(){} }

If you write:

A obj = new B();
obj.display();

JVM checks the object type (B) at runtime
ğŸ‘‰ It calls Bâ€™s version of display()

ğŸ§ Real-life example:

Imagine you use a credit card to pay:
If it's a Visa card, the Visa bank rules apply
If it's a MasterCard, MasterCard rules apply
Machine sees the actual card type at runtime, not before.

--------------------------------------------------------------------------------------------------------

ğŸŸ£ Method Overloading

ğŸ‘‰ Definition

Method Overloading means multiple methods with: 

Same method name

BUT

Different parameter list

ğŸ’¡ Why is it useful?

Because we want the same action name, but for different types of inputs.

Example:

print(int)
print(String)
print(double)

Same purpose: print something
Different type of data â†’ different method

--------------------------------------------------------------------------------------------------------

ğŸ“˜ Three Ways to Overload a Method

--------------------------------------------------------------------------------------------------------

1ï¸âƒ£ Different number of parameters

public void display(int a) {}
public void display(int a, int b) {}

--------------------------------------------------------------------------------------------------------

2ï¸âƒ£ Different type of parameters

public void show(int a) {}
public void show(double a) {}

--------------------------------------------------------------------------------------------------------

3ï¸âƒ£ Different order of parameters

public void test(int a, double b) {}
public void test(double a, int b) {}

--------------------------------------------------------------------------------------------------------

ğŸ¦ Real-life Example for Method Overloading

You go to a shop to make payment:

You may pay using Cash
Or UPI
Or Credit Card

All these are payments â†’ same method name
But the type of payment is different

public void makePayment(Cash c) {}
public void makePayment(UPI c) {}
public void makePayment(CreditCard c) {}

ğŸ‘‰ The cashier handles all with the same name "payment"
But behavior differs depending on the parameter (Cash/UPI/Card)

--------------------------------------------------------------------------------------------------------

ğŸ“Œ Rules for Method Overloading

âœ” Same method name
âœ” Must differ in number/type/order of parameters
âœ” Return type can be different
âœ” Access modifiers can change
âœ” Static methods can be overloaded
âœ” Java automatically promotes types
(int â†’ long â†’ float â†’ double)

âŒ Cannot overload only by changing return type
Because compiler gets confused which one to call.

--------------------------------------------------------------------------------------------------------

ğŸ¯ Advantages of Method Overloading

â­ Makes code cleaner
â­ Same method name reused â†’ better readability
â­ Handles different inputs easily
â­ Very useful in real classes (PrintStream, Scanner)

Example:
println() has 10+ versions for int, char, float, String, boolean, etc.

--------------------------------------------------------------------------------------------------------



