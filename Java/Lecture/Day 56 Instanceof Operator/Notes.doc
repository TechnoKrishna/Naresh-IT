-------------------------------------------------------------------------------
ğŸ“˜ Instanceof Operator
-------------------------------------------------------------------------------

âœ” What is instanceof?

instanceof is a special operator in Java that checks:

ğŸ‘‰ â€œIs this object a member of this class?â€
It returns only true or false.


Example thought:
If you ask:
"Is this apple a fruit?" â†’ Yes â†’ true
"Is this apple a vehicle?" â†’ No â†’ false

Thatâ€™s exactly how instanceof works.

ğŸ“Œ Important Points

instanceof is a keyword and a relational operator.

It is mainly used to check object type before using it.

It is very important when you want to do downcasting (converting parent reference to child type).

It helps you avoid ClassCastException (runtime error).

It requires an IS-A relationship (inheritance).

Without inheritance â†’ âŒ Compilation Error

-------------------------------------------------------------------------------

ğŸ“Œ Program 1: Basic instanceof

====================================

class Test { }

public class InstanceOfDemo1 {
    public static void main(String[] args) {
        Test t1 = new Test();

        if (t1 instanceof Test) {
            System.out.println("t1 is pointing to Test Object");
        }
    }
}

====================================

âœ” Easy Explanation

Here Java checks whether t1 belongs to the class Test.
Since we created t1 using new Test(), the answer is true.

====================================

âœ” Real-Life Example

Think like:
You have a student ID card.
The college checks:
"Is this person a student?" â†’ true
"Is this person a faculty?" â†’ false

-------------------------------------------------------------------------------

ğŸ“Œ Program 2: instanceof with Multilevel Inheritance

====================================

class Alpha { }
class Beta extends Alpha { }
class Gamma extends Beta { }

public class InstanceOfDemo2 {
    public static void main(String[] args) {
        Gamma g = new Gamma();

        if (g instanceof Gamma) {
            System.out.println("g is pointing to Gamma Object");
        }
        if (g instanceof Beta) {
            System.out.println("g is pointing to Beta Object");
        }
        if (g instanceof Alpha) {
            System.out.println("g is pointing to Alpha Object");
        }
        if (g instanceof Object) {
            System.out.println("g is pointing to Object class Object");
        }
    }
}

====================================

âœ” Easy Explanation

Gamma extends Beta â†’ Beta extends Alpha â†’ Alpha extends Object.

So, a Gamma object is also:

Gamma
Beta
Alpha
Object

This is the IS-A chain.

====================================

âœ” Real-Life Example

A Doctor IS-A Employee
Employee IS-A Human
Human IS-A Living Being

So if you check:

"Is doctor a doctor?" â†’ true
"Is doctor an employee?" â†’ true
"Is doctor a human?" â†’ true
"Is doctor a living being?" â†’ true

-------------------------------------------------------------------------------

ğŸ“Œ Program 3: Invalid instanceof (No IS-A Relation)

====================================

class Bird {
    public void fly() {
        System.out.println("Bird can fly");
    }
}

class Fish {
    public void swim() {
        System.out.println("Fish can swim");
    }
}

public class InstanceOfDemo3 {
    public static void main(String[] args) {
        Fish fish = new Fish();
        
        if (fish instanceof Bird) {  // âŒ Error: No IS-A relation
        }
    }
}

====================================

âœ” Easy Explanation

Bird and Fish are totally different. They do not have any IS-A relationship.

So compiler says:
âŒ â€œI canâ€™t compare Fish and Bird.â€

====================================

âœ” Real-Life Example

Checking:
"Is a car a laptop?" â†’ No relation â†’ invalid check.

-------------------------------------------------------------------------------

ğŸ“Œ Program 4: instanceof with Method Parameter

====================================

class Vehicle {
    public void run() {
        System.out.println("Vehicle is running");
    }
}
class BMW extends Vehicle { }
class Audi extends Vehicle { }
class Naxon extends Vehicle { }

public class InstanceOfDemo4 {
    public static void main(String[] args) {
        Audi a = new Audi();
        acceptCarType(a);
    }

    public static void acceptCarType(Vehicle v) {
        if (v instanceof BMW) {
            System.out.println("BMW Car");
        } else {
            System.out.println("AUDI Car");
        }
    }
}

====================================

acceptCarType() receives a Vehicle reference.
It checks whether the passed vehicle is a BMW.
If not â†’ prints AUDI.

====================================

âœ” Real-Life Example

When someone walks into a parking area, security checks:
If car brand is BMW â†’ Special parking
Else â†’ Normal parking

-------------------------------------------------------------------------------

ğŸŸ¦ Co-Variant Return Type in Java

====================================

Normally, when you override a method:

Method name must match
Arguments must match
Return type must be same

But from Java 1.5, Java introduced Co-Variant Return Types.

âœ” What is Co-Variant Return Type?
The overridden method in subclass can return a subclass type of the return type in the parent class.

ğŸ‘‰ If parent returns Animal, child can return Dog.
ğŸ‘‰ If parent returns Number, child can return Integer.

âœ” Why was this introduced?
To make class design flexible and avoid unnecessary typecasting.

âœ” Important Rule
Co-variant works only for non-primitive types (objects).

âŒ int, float, double â†’ not allowed
âœ” Animal, Vehicle, Number â†’ allowed

-------------------------------------------------------------------------------

âŒ Without Co-Variant â€“ Incompatible Return Type

====================================

class Shape {
    public void draw() {
        System.out.println("Generic Draw");
    }
}

class Square extends Shape {
    @Override
    public int draw() { // âŒ Error: int not compatible with void
        System.out.println("Drawing Square");
        return 0;
    }
}

====================================

âœ” Easy Explanation

Parent method returns void.
Child method returns int â†’ not allowed.
Primitive types cannot use co-variant return.

-------------------------------------------------------------------------------

âœ” Program Using Co-Variant Return Type

====================================

class Alpha { }
class Beta extends Alpha { }

class Vehicle {
    public Alpha run() {
        System.out.println("Generic Vehicle is Running");
        return null;
    }
}

class Car extends Vehicle {
    @Override
    public Beta run() {
        System.out.println("Car Vehicle is Running");
        return null;
    }
}

public class CoVariantDemo {
    public static void main(String[] args) {
        Vehicle v = new Car();
        v.run();
    }
}

====================================

âœ” Easy Explanation

Parent returns Alpha
Child returns Beta

Since Beta extends Alpha, return type is compatible.

====================================

âœ” Real-Life Example

Parent method returns "Fruit"
Child method returns "Apple"

Apple IS-A Fruit â†’ allowed.

-------------------------------------------------------------------------------

ğŸ“Œ Second Example â€“ With Wrapper Classes

====================================

class RBI {
    public Number loan() {
        System.out.println("Bank should provide loan");
        return null;
    }
}

class SBI extends RBI {
    @Override
    public Float loan() {  // âœ” Float IS-A Number
        System.out.println("Providing loan @ 9.2% ROI");
        return null;
    }
}

public class CoVariantDemo2 {
    public static void main(String[] args) {
        RBI r = new SBI();
        r.loan();
    }
}

====================================

âœ” Easy Explanation

Parent returns Number

Child returns Float
Float is a subclass of Number â†’ allowed.

-------------------------------------------------------------------------------

ğŸ¯ Quick Revision Notes


âœ” instanceof Operator

Used to check object type
Returns true/false
Avoids ClassCastException
Needs inheritance (IS-A)
Cannot be used with unrelated classes

====================================

âœ” Co-Variant Return Type

Allowed from JDK 1.5
Works only for objects
Child overridden method can return:
âœ” A subclass of parent return type
Example:
Parent returns Animal, child returns Dog
âŒ Not allowed for int, float, char (primitive types)

-------------------------------------------------------------------------------
